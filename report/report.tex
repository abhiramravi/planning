\documentclass{article}
\usepackage{fullpage}
\usepackage{multicol}
\usepackage[colorlinks=true,citecolor=black,linkcolor=black,urlcolor=black]{hyperref}

\title{
{\large 15-887: Planning, Execution, and Learning}\\
Project Report}
\author{Carlo Angiuli \and Ben Blum \and Michael Sullivan}
\date{December 3, 2012}

\begin{document}
\maketitle

\section{Introduction}

Program verification is the problem of showing that a computer program correctly
implements a specification of its intended behavior, or finding a
counterexample. These verifications can be either \emph{formal} or
\emph{informal}. In formal verification, one mathematically defines both the
specification and the program's own semantics, using techniques such as
substructural operational semantics~\cite{rob}, and proves that these coincide.

Informal verifications are prone to false positives or false negatives---but are
more immediately applicable to a broader range of programs. Informal analyses
are often used in systems research to reason about ill-specified code ``in the
real world'', which is especially useful for finding concurrency
errors~\cite{ben}.

{\em Planners} take a domain definition and initial state, and compute a
sequence of actions for achieving a goal; a planner is {\em complete} when its
failure to achieve a goal guarantees that no sequence of actions can achieve
that goal.
We investigate the correspondence between planning and program verification: the domain is the programming language (or the abstract machine), the initial state is the program being verified, the goal is the specification, and the plans are execution traces.
If a complete planner cannot plan for an invalid state, this constitutes a
formal verification that a program is safe (assuming that the planner is
correct).

We investigate how planners can be used for program verification in two particular domains:
first, for reasoning about functional and logic programs using an encoding
inspired by substructural operational semantics,
and second, for reasoning about concurrent computation with a focus on synchronisation algorithms.
Our results are mixed.
Of the (how many?) modern planners we used, none were able to efficiently execute lambda calculus programs. % TODO how many
On the other hand, we found planners were quite efficient at checking concurrent programs against their specifications,
and could even be used to reason about potentially nonterminating programs, which is a sticking point for many modern model checkers. % is this really true?
Inspired by this, we also provide a compiler for automatically generating PDDL
domains for concurrent programs from a more natural representation.
We discuss why modern planners proved inadequate for reasoning about functional programming, and also discuss the implications for concurrency verification.

\section{Functional and logic programming}

\input{functional.tex}

\section{Concurrent imperative programming}

\input{concurrent.tex}

\bibliography{citations}{}
\bibliographystyle{alpha}

\end{document}

The report should be 4-6 pages and include descriptions of (1) the problem,
(2) your approach, and (3) your results.  Please highlight the planning aspects
and other course concepts in all of the sections.  You may want to include some
references to related work in the background for your problem description or in
the evaluation of your results, but you do not need to include a separate
related work survey.

