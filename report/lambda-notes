demo-domain/demo.pddl -
The file also contains the original evaluation rules for zero, successor, and
predecessor that I used to test the methodology of pointerizing syntax
trees and generating labels for programs. That let us compute things
like succ(pred(succ(zero))) = succ(zero).

lambda.pddl - I tried implementing substitution in a very backwards
chaining logic programming sort of way. The fact "subst e1 x e2 e"
expresses that [e1/x]e2 = e.

This also contains the demo domain rules...?
I thought I had actually written the lambda calculus evaluation rules
in terms of subst, but it looks like I actually gave up on that once
subst blew up the entire world on its own.

lambda-ctx.pddl -
Here I do have a full abstract machine lambda calculus interpreter
that uses contexts instead of substitution. It generates closures when
evaluating lambdas. Closures are lists expressed as "binding"
facts. They are linked lists with labels allocated with the label
allocator.
This also doesn't work.

Variable lookup is done with a recursively defined "derived predicate"
called "is-bound". This is not super widely supported. It could be
rewritten to not use derived predicates, but this might cause more
efficiency problems.
The planner still runs out of memory even if I comment out is-bound
and the variable rule that uses it.

lambda-ctx does partially seperate out different sorts of labels. It
uses "address" for program stuff and "label" for conts and
bindings. Maybe seperating out conts and bindings would help, but I
haven't tried it.
